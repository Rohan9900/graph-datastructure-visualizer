"use strict";
self["webpackHotUpdategraph_data_structure_visualizer"]("Graph-stories",{

/***/ "./stories/Graph.js":
/*!**************************!*\
  !*** ./stories/Graph.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphVisualizer: () => (/* binding */ GraphVisualizer)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


function GraphVisualizer({
  canvasRef,
  data,
  isChange,
  startingPoint,
  textColor,
  mainHeight,
  mainWidth,
  nodeShape
}) {
  if (!canvasRef) {
    canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  }
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    let pos = {};
    let connections = {};
    let visited = {};
    recurseGraph(visited, startingPoint, 100, 300, ctx, pos, connections, canvas);
  }, [isChange]);
  const adjustPosition = (x, y, radius) => {
    const padding = 10; // Padding around nodes
    const minX = radius + padding;
    const maxX = mainWidth - radius - padding;
    const minY = radius + padding;
    const maxY = mainHeight - radius - padding;
    x = Math.max(minX, Math.min(maxX, x));
    y = Math.max(minY, Math.min(maxY, y));
    return {
      x,
      y
    };
  };
  const recurseGraph = (vis, node, x, y, ctx, pos, connections, canvas) => {
    if (!vis[node]) {
      const text = node;
      const textWidth = ctx.measureText(text).width;
      const paddingX = 10;
      const contentWidth = textWidth + 2 * paddingX;
      const contentHeight = 30;
      const nodeWidth = contentWidth;
      const nodeHeight = contentHeight;
      const nodeRadius = Math.max(nodeWidth, nodeHeight) / 2;
      const adjustedPos = adjustPosition(x, y, nodeRadius);
      x = adjustedPos.x;
      y = adjustedPos.y;
      ctx.clearRect(x - nodeRadius, y - nodeRadius, 2 * nodeRadius, 2 * nodeRadius);
      if (nodeShape === "circle") {
        ctx.beginPath();
        ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
        ctx.fillStyle = "#ffffff"; // White background for circle
        ctx.fill();
        ctx.stroke();
      } else {
        ctx.fillStyle = "#e0e0e0";
        ctx.fillRect(x - nodeWidth / 2, y - nodeHeight / 2, nodeWidth, nodeHeight);
      }
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x, y);
      pos[node] = {
        x: x,
        y: y
      };
      vis[node] = true;
      const neighbors = data[node];
      const neighborCount = neighbors.length;
      let yOffset = -(neighborCount - 1) * 50;
      for (let i = 0; i < neighborCount; i++) {
        const neighbor = neighbors[i];
        const newX = x + 200;
        var newY = calculateNewY(yOffset, newY, neighborCount);
        if (!connections[`${node}-${neighbor}`] && !connections[`${neighbor}-${node}`]) {
          ctx.beginPath();
          const startNodeRadius = Math.max(ctx.measureText(node).width + 20, 30) / 2;
          const endNodeRadius = Math.max(ctx.measureText(neighbor).width + 20, 30) / 2;
          const startNodeX = pos[node] ? pos[node].x : newX;
          const startNodeY = pos[node] ? pos[node].y : newY;
          const endNodeX = pos[neighbor] ? pos[neighbor].x : newX;
          const endNodeY = pos[neighbor] ? pos[neighbor].y : newY;
          const dx = endNodeX - startNodeX;
          const dy = endNodeY - startNodeY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const offsetX = dx / distance * startNodeRadius;
          const offsetY = dy / distance * startNodeRadius;
          ctx.moveTo(startNodeX + offsetX, startNodeY + offsetY);
          ctx.lineTo(endNodeX - dx / distance * endNodeRadius, endNodeY - dy / distance * endNodeRadius);
          ctx.stroke();
          connections[`${node}-${neighbor}`] = true;
        }
        recurseGraph(vis, neighbor, newX, newY, ctx, pos, connections, canvas);
        yOffset += 100;
      }
    }
  };
  const calculateNewY = (yOffset, y, neighborCount) => {
    const minYOffset = -((neighborCount - 1) * 50);
    const maxYOffset = (neighborCount - 1) * 50;
    const availableSpace = maxYOffset - minYOffset;
    if (availableSpace > 0) {
      return y + (yOffset - minYOffset) * (canvas.height / availableSpace);
    } else {
      return y + yOffset;
    }
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("canvas", {
    ref: canvasRef,
    width: mainWidth,
    height: mainHeight
  });
}
GraphVisualizer.displayName = "GraphVisualizer";
GraphVisualizer.defaultProps = {
  mainHeight: 400,
  mainWidth: 500,
  textColor: "black",
  data: {},
  nodeShape: "rectangle"
};
GraphVisualizer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "GraphVisualizer",
  "props": {
    "mainHeight": {
      "defaultValue": {
        "value": "400",
        "computed": false
      },
      "required": false
    },
    "mainWidth": {
      "defaultValue": {
        "value": "500",
        "computed": false
      },
      "required": false
    },
    "textColor": {
      "defaultValue": {
        "value": "\"black\"",
        "computed": false
      },
      "required": false
    },
    "data": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "required": false
    },
    "nodeShape": {
      "defaultValue": {
        "value": "\"rectangle\"",
        "computed": false
      },
      "required": false
    }
  }
};

/***/ })

});
//# sourceMappingURL=Graph-stories.61afac8509220f84a9f2.hot-update.js.map