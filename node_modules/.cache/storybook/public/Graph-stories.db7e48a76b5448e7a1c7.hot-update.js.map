{"version":3,"file":"Graph-stories.db7e48a76b5448e7a1c7.hot-update.js","mappings":";;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAUA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AA5JA;AA8JA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sources":["webpack://graph-data-structure-visualizer/./stories/Graph.js"],"sourcesContent":["import React from \"react\";\n\nimport { useEffect } from \"react\";\nimport { useRef } from \"react\";\n\nexport function GraphVisualizer({\n  canvasRef,\n  data,\n  isChange,\n  startingPoint,\n  textColor,\n  mainHeight,\n  mainWidth,\n}) {\n  if (!canvasRef) {\n    canvasRef = useRef(null);\n  }\n\n  const containerRef = useRef(null);\n  const contextRef = useRef(null);\n\n  const scaleFactor = 1.5; // Adjust this for zoom levels\n  const canvasWidth = 8000; // Initial canvas width\n  const canvasHeight = 6000; // Initial canvas height\n  let canvasX = 0;\n  let canvasY = 0;\n\n  useEffect(() => {\n    drawCanvas();\n  }, [isChange]);\n\n  /* -------------------------------------------------------------------------- */\n  /*                                draw a canvas                               */\n  /* -------------------------------------------------------------------------- */\n  const drawCanvas = () => {\n    /* -------------------------------------------------------------------------- */\n    /*                             initializing canvas                            */\n    /* -------------------------------------------------------------------------- */\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    /* -------------------------------------------------------------------------- */\n    /*                 creating a canvas of some height and width                 */\n    /* -------------------------------------------------------------------------- */\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    let pos = {};\n    let connections = {};\n    let visited = {};\n\n    /* -------------------------------------------------------------------------- */\n    /*                          recursing graph with dfs                          */\n    /* -------------------------------------------------------------------------- */\n    recurseGraph(\n      visited,\n      startingPoint,\n      100,\n      300,\n      ctx,\n      pos,\n      connections,\n      canvas\n    );\n  };\n\n  const recurseGraph = (vis, node, x, y, ctx, pos, connections, canvas) => {\n    if (!vis[node]) {\n      const width = 100; // Rectangle width\n      const height = 30; // Rectangle height\n\n      ctx.strokeRect(x - width / 2, y - height / 2, width, height);\n      ctx.fillStyle = textColor;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node, x, y);\n\n      pos[node] = { x: x, y: y };\n\n      vis[node] = true;\n      const neighbors = data[node];\n      const neighborCount = neighbors.length;\n      let yOffset = -(neighborCount - 1) * 50;\n\n      for (let i = 0; i < neighborCount; i++) {\n        const neighbor = neighbors[i];\n        const newX = x + 200;\n        const newY = y + yOffset;\n\n        if (\n          !connections[`${node}-${neighbor}`] &&\n          !connections[`${neighbor}-${node}`]\n        ) {\n          ctx.beginPath();\n          ctx.moveTo(x + width / 2, y);\n          ctx.lineTo(\n            pos[neighbor] ? pos[neighbor].x - width / 2 : newX - width / 2,\n            pos[neighbor] ? pos[neighbor].y : newY\n          );\n          ctx.stroke();\n          connections[`${node}-${neighbor}`] = true;\n        }\n\n        recurseGraph(vis, neighbor, newX, newY, ctx, pos, connections, canvas);\n        yOffset += 200;\n      }\n    }\n  };\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext(\"2d\");\n    contextRef.current = context;\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    drawCanvas();\n  }, []);\n\n  const handleMouseMove = (e) => {\n    if (e.buttons === 1) {\n      canvasX -= e.movementX;\n      canvasY -= e.movementY;\n      drawCanvas();\n    }\n  };\n\n  const handleWheel = (e) => {\n    const delta = Math.sign(e.deltaY);\n    const zoomAmount = delta > 0 ? scaleFactor : 1 / scaleFactor;\n    const canvas = canvasRef.current;\n\n    const canvasRect = canvas.getBoundingClientRect();\n    const mouseX = e.clientX - canvasRect.left;\n    const mouseY = e.clientY - canvasRect.top;\n\n    const canvasXBeforeZoom = canvasX + mouseX;\n    const canvasYBeforeZoom = canvasY + mouseY;\n\n    canvasX = (canvasXBeforeZoom - mouseX) * zoomAmount + mouseX;\n    canvasY = (canvasYBeforeZoom - mouseY) * zoomAmount + mouseY;\n\n    canvasX = Math.max(canvasX, 0);\n    canvasY = Math.max(canvasY, 0);\n\n    canvas.width = canvasWidth * scaleFactor;\n    canvas.height = canvasHeight * scaleFactor;\n\n    drawCanvas();\n  };\n\n  return (\n    <div\n      ref={containerRef}\n      style={{ overflow: \"hidden\", width: \"100%\", height: \"100%\" }}\n      onMouseMove={handleMouseMove}\n      onWheel={handleWheel}\n    >\n      <canvas ref={canvasRef} />\n    </div>\n  );\n}\n\nGraphVisualizer.defaultProps = {\n  mainHeight: 400,\n  mainWidth: 500,\n  textColor: \"black\",\n  data: {},\n};\n"],"names":[],"sourceRoot":""}