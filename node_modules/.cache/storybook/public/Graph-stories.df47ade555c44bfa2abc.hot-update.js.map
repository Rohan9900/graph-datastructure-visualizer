{"version":3,"file":"Graph-stories.df47ade555c44bfa2abc.hot-update.js","mappings":";;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;;AAEA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAIA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAjIA;AAmIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sources":["webpack://graph-data-structure-visualizer/./stories/Graph.js"],"sourcesContent":["import React from \"react\";\n\nimport { useEffect } from \"react\";\nimport { useRef } from \"react\";\n\nexport function GraphVisualizer({\n  canvasRef,\n  data,\n  isChange,\n  startingPoint,\n  textColor,\n  mainHeight,\n  mainWidth,\n}) {\n  if (!canvasRef) {\n    canvasRef = useRef(null);\n  }\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    /* -------------------------------------------------------------------------- */\n    /*                 Calculate required canvas dimensions                        */\n    /* -------------------------------------------------------------------------- */\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const getNodePosition = (nodeId) => {\n      // Modify this function based on your data structure\n      // Assuming data is an object with nodes as keys and their positions as values\n      // For this example, we'll set positions based on a predefined gap between nodes\n      const horizontalGap = 150;\n      const verticalGap = 100;\n\n      // Assuming the nodes are sorted in a topological order\n      // Based on the provided data, the nodes are sorted as: A -> B -> C -> D -> E -> F -> ...\n      const nodeIndex = Object.keys(data).indexOf(nodeId);\n\n      // Calculate the X and Y positions based on the index\n      const x = nodeIndex * horizontalGap;\n      const y = 0; // All nodes are aligned vertically (y = 0)\n\n      return { x, y };\n    };\n\n    // ... Y\n\n    // Loop through all nodes to find the bounding box of the graph\n    Object.keys(data).forEach((node) => {\n      const { x, y } = getNodePosition(node);\n      minX = Math.min(minX, x);\n      minY = Math.min(minY, y);\n      maxX = Math.max(maxX, x);\n      maxY = Math.max(maxY, y);\n    });\n\n    // Calculate required canvas dimensions based on the bounding box with some padding\n    const padding = 50;\n    const canvasWidth = maxX - minX + padding * 2;\n    const canvasHeight = maxY - minY + padding * 2;\n\n    // Set canvas dimensions\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n\n    // Translate the canvas content to center the drawing\n    const centerX = canvasWidth / 2;\n    const centerY = canvasHeight / 2;\n    ctx.translate(centerX - minX + padding, centerY - minY + padding);\n\n\n\n    // Translate the canvas content to center the X and Y axes\n    ctx.translate(centerX, centerY);\n\n    let pos = {};\n    let connections = {};\n    let visited = {};\n\n    /* -------------------------------------------------------------------------- */\n    /*                          recursing graph with dfs                          */\n    /* -------------------------------------------------------------------------- */\n    recurseGraph(visited, startingPoint, 100, 0, ctx, pos, connections);\n  }, [isChange]);\n\n  const recurseGraph = (vis, node, x, y, ctx, pos, connections) => {\n    if (!vis[node]) {\n      const width = 100; // Rectangle width\n      const height = 30; // Rectangle height\n\n      ctx.strokeRect(x - width / 2, y - height / 2, width, height);\n      ctx.fillStyle = textColor;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node, x, y);\n\n      pos[node] = { x: x, y: y };\n\n      vis[node] = true;\n      const neighbors = data[node];\n      const neighborCount = neighbors.length;\n      let yOffset = -(neighborCount - 1) * 50;\n\n      for (let i = 0; i < neighborCount; i++) {\n        const neighbor = neighbors[i];\n        const newX = x + 200;\n        const newY = y + yOffset;\n\n        if (\n          !connections[`${node}-${neighbor}`] &&\n          !connections[`${neighbor}-${node}`]\n        ) {\n          ctx.beginPath();\n          ctx.moveTo(x + width / 2, y);\n          ctx.lineTo(\n            pos[neighbor] ? pos[neighbor].x - width / 2 : newX - width / 2,\n            pos[neighbor] ? pos[neighbor].y : newY\n          );\n          ctx.stroke();\n          connections[`${node}-${neighbor}`] = true;\n        }\n\n        recurseGraph(vis, neighbor, newX, newY, ctx, pos, connections);\n        yOffset += 100;\n      }\n    }\n  };\n  return <canvas ref={canvasRef} width={mainWidth} height={mainHeight} />;\n}\n\n// GraphVisualizer.propTypes = {\n//   canvasRef: PropTypes.func.isRequired,\n//   data: PropTypes.object.isRequired,\n//   isChange: PropTypes.bool.isRequired,\n//   startingPoint: PropTypes.string.isRequired,\n//   textColor: PropTypes.string.isRequired,\n//   mainHeight: PropTypes.number.isRequired,\n//   mainWidth: PropTypes.number.isRequired,\n// };\n\nGraphVisualizer.defaultProps = {\n  mainHeight: 400,\n  mainWidth: 500,\n  textColor: \"black\",\n  data: {},\n};\n"],"names":[],"sourceRoot":""}