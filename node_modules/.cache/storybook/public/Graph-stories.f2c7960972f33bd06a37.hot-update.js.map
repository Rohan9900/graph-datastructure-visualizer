{"version":3,"file":"Graph-stories.f2c7960972f33bd06a37.hot-update.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAlIA;AAoIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA","sources":["webpack://graph-data-structure-visualizer/./stories/Graph.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\n\nexport function GraphVisualizer({\n  canvasRef,\n  data,\n  isChange,\n  startingPoint,\n  textColor,\n  mainHeight,\n  mainWidth,\n}) {\n  if (!canvasRef) {\n    canvasRef = useRef(null);\n  }\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    // Calculate graph dimensions based on node positions\n    const graphDimensions = calculateGraphDimensions(data, startingPoint);\n\n    // Calculate scaling factors for both X and Y dimensions\n    const scaleFactorX = (mainWidth - 20) / graphDimensions.width; // Leave some padding\n    const scaleFactorY = (mainHeight - 20) / graphDimensions.height;\n\n    // Clear the canvas\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Save the current context state before applying scaling\n    ctx.save();\n\n    // Apply scaling and transformations\n    ctx.scale(scaleFactorX, scaleFactorY);\n\n    // Initialize variables\n    let pos = {};\n    let connections = {};\n    let visited = {};\n\n    // Recurse through the graph and draw nodes and connections\n    recurseGraph(visited, startingPoint, 100, 300, ctx, pos, connections);\n\n    // Restore the context to the original state\n    ctx.restore();\n  }, [isChange]);\n\n  const calculateGraphDimensions = (data, startingPoint) => {\n    // Initialize variables to track minimum and maximum coordinates\n    let minX = Number.MAX_VALUE;\n    let maxX = Number.MIN_VALUE;\n    let minY = Number.MAX_VALUE;\n    let maxY = Number.MIN_VALUE;\n\n    // Helper function to traverse graph nodes and update coordinates\n    const traverseGraph = (node, x, y) => {\n      // Update min and max coordinates\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n\n      // Adjust newX and newY based on your graph structure\n      const newX = x + 200;\n      const newY = y;\n\n      const neighbors = data[node];\n      for (const neighbor of neighbors) {\n        traverseGraph(neighbor, newX, newY);\n      }\n    };\n\n    // Start traversal from the starting point with initial coordinates (0, 0)\n    traverseGraph(startingPoint, 0, 0);\n\n    // Calculate and return width and height of the graph based on coordinates\n    const width = maxX - minX;\n    const height = maxY - minY;\n    return { width, height };\n  };\n\n  const recurseGraph = (vis, node, x, y, ctx, pos, connections) => {\n    if (!vis[node]) {\n      const width = 100; // Rectangle width\n      const height = 30; // Rectangle height\n\n      // Scale and adjust node positions to fit within canvas\n      const scaledX = x;\n      const scaledY = y;\n      if (scaledX < width / 2) scaledX = width / 2;\n      if (scaledX > ctx.canvas.width - width / 2) scaledX = ctx.canvas.width - width / 2;\n      if (scaledY < height / 2) scaledY = height / 2;\n      if (scaledY > ctx.canvas.height - height / 2) scaledY = ctx.canvas.height - height / 2;\n\n      // Draw node rectangle and text\n      ctx.strokeRect(scaledX - width / 2, scaledY - height / 2, width, height);\n      ctx.fillStyle = textColor;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(node, scaledX, scaledY);\n\n      // Update node position\n      pos[node] = { x: scaledX, y: scaledY };\n\n      vis[node] = true;\n      const neighbors = data[node];\n      const neighborCount = neighbors.length;\n      let yOffset = -(neighborCount - 1) * 50;\n\n      for (let i = 0; i < neighborCount; i++) {\n        const neighbor = neighbors[i];\n        const newX = scaledX + 200;\n        const newY = scaledY + yOffset;\n\n        if (!connections[`${node}-${neighbor}`] && !connections[`${neighbor}-${node}`]) {\n          ctx.beginPath();\n          ctx.moveTo(scaledX + width / 2, scaledY);\n          ctx.lineTo(\n            pos[neighbor] ? pos[neighbor].x - width / 2 : newX - width / 2,\n            pos[neighbor] ? pos[neighbor].y : newY\n          );\n          ctx.stroke();\n          connections[`${node}-${neighbor}`] = true;\n        }\n\n        recurseGraph(vis, neighbor, newX, newY, ctx, pos, connections);\n        yOffset += 100;\n      }\n    }\n  };\n\n  return <canvas ref={canvasRef} width={mainWidth} height={mainHeight} />;\n}\n\nGraphVisualizer.defaultProps = {\n  mainHeight: 400,\n  mainWidth: 500,\n  textColor: \"black\",\n  data: {},\n};\n\nexport default GraphVisualizer;\n"],"names":[],"sourceRoot":""}