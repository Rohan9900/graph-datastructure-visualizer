{"version":3,"file":"Graph-stories.9e23cc5e2a4ee8a21957.hot-update.js","mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAnHA;AAqHA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sources":["webpack://graph-data-structure-visualizer/./stories/Graph.js"],"sourcesContent":["import React, { useEffect, useRef } from \"react\";\n\nexport function GraphVisualizer({\n  canvasRef,\n  data,\n  isChange,\n  startingPoint,\n  textColor,\n  mainHeight,\n  mainWidth,\n  nodeShape,\n}) {\n  if (!canvasRef) {\n    canvasRef = useRef(null);\n  }\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    let pos = {};\n    let connections = {};\n    let visited = {};\n\n    recurseGraph(visited, startingPoint, 100, 300, ctx, pos, connections, canvas);\n\n  }, [isChange]);\n\n  const adjustPosition = (x, y, radius) => {\n    const padding = 10; // Padding around nodes\n    const minX = radius + padding;\n    const maxX = mainWidth - radius - padding;\n    const minY = radius + padding;\n    const maxY = mainHeight - radius - padding;\n\n    x = Math.max(minX, Math.min(maxX, x));\n    y = Math.max(minY, Math.min(maxY, y));\n\n    return { x, y };\n  };\n\n  const recurseGraph = (vis, node, x, y, ctx, pos, connections, canvas) => {\n    if (!vis[node]) {\n      const text = node;\n      const textWidth = ctx.measureText(text).width;\n      const paddingX = 10;\n      const contentWidth = textWidth + 2 * paddingX;\n      const contentHeight = 30;\n\n      const nodeWidth = contentWidth;\n      const nodeHeight = contentHeight;\n      const nodeRadius = Math.max(nodeWidth, nodeHeight) / 2;\n\n      const adjustedPos = adjustPosition(x, y, nodeRadius);\n      x = adjustedPos.x;\n      y = adjustedPos.y;\n\n      ctx.clearRect(x - nodeRadius, y - nodeRadius, 2 * nodeRadius, 2 * nodeRadius);\n\n      if (nodeShape === \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);\n        ctx.fillStyle = \"#ffffff\"; // White background for circle\n        ctx.fill();\n        ctx.stroke();\n      } else {\n        ctx.fillStyle = \"#e0e0e0\";\n        ctx.fillRect(x - nodeWidth / 2, y - nodeHeight / 2, nodeWidth, nodeHeight);\n      }\n\n      ctx.fillStyle = textColor;\n      ctx.textAlign = \"center\";\n      ctx.textBaseline = \"middle\";\n      ctx.fillText(text, x, y);\n\n      pos[node] = { x: x, y: y };\n\n      vis[node] = true;\n      const neighbors = data[node];\n      const neighborCount = neighbors.length;\n      let yOffset = -(neighborCount - 1) * 50;\n\n      for (let i = 0; i < neighborCount; i++) {\n        const neighbor = neighbors[i];\n        const newX = x + 100;\n        const newY = y + yOffset;\n\n        if (\n          !connections[`${node}-${neighbor}`] &&\n          !connections[`${neighbor}-${node}`]\n        ) {\n          ctx.beginPath();\n          const startNodeRadius = Math.max(ctx.measureText(node).width + 20, 30) / 2;\n          const endNodeRadius = Math.max(ctx.measureText(neighbor).width + 20, 30) / 2;\n          const startNodeX = pos[node] ? pos[node].x : newX;\n          const startNodeY = pos[node] ? pos[node].y : newY;\n          const endNodeX = pos[neighbor] ? pos[neighbor].x : newX;\n          const endNodeY = pos[neighbor] ? pos[neighbor].y : newY;\n          const dx = endNodeX - startNodeX;\n          const dy = endNodeY - startNodeY;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          const offsetX = (dx / distance) * startNodeRadius;\n          const offsetY = (dy / distance) * startNodeRadius;\n          ctx.moveTo(startNodeX + offsetX, startNodeY + offsetY);\n          ctx.lineTo(endNodeX - (dx / distance) * endNodeRadius, endNodeY - (dy / distance) * endNodeRadius);\n          ctx.stroke();\n          connections[`${node}-${neighbor}`] = true;\n        }\n\n        recurseGraph(vis, neighbor, newX, newY, ctx, pos, connections, canvas);\n        yOffset += 100;\n      }\n    }\n  };\n\n  return <canvas ref={canvasRef} width={mainWidth} height={mainHeight} />;\n}\n\nGraphVisualizer.defaultProps = {\n  mainHeight: 400,\n  mainWidth: 500,\n  textColor: \"black\",\n  data: {},\n  nodeShape: \"rectangle\",\n};\n"],"names":[],"sourceRoot":""}