"use strict";
self["webpackHotUpdategraph_data_structure_visualizer"]("Graph-stories",{

/***/ "./stories/Graph.js":
/*!**************************!*\
  !*** ./stories/Graph.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphVisualizer: () => (/* binding */ GraphVisualizer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


function GraphVisualizer({
  canvasRef,
  data,
  isChange,
  startingPoint,
  textColor,
  mainHeight,
  mainWidth
}) {
  if (!canvasRef) {
    canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  }
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    // Calculate graph dimensions based on node positions
    const graphDimensions = calculateGraphDimensions(data, startingPoint);

    // Calculate scaling factors for both X and Y dimensions
    const scaleFactorX = (mainWidth - 20) / graphDimensions.width; // Leave some padding
    const scaleFactorY = (mainHeight - 20) / graphDimensions.height;

    // Clear the canvas
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // Save the current context state before applying scaling
    ctx.save();

    // Apply scaling and transformations
    ctx.scale(scaleFactorX, scaleFactorY);

    // Initialize variables
    let pos = {};
    let connections = {};
    let visited = {};

    // Recurse through the graph and draw nodes and connections
    recurseGraph(visited, startingPoint, 100, 300, ctx, pos, connections);

    // Restore the context to the original state
    ctx.restore();
  }, [isChange]);
  const calculateGraphDimensions = (data, startingPoint) => {
    // Initialize variables to track minimum and maximum coordinates
    let minX = Number.MAX_VALUE;
    let maxX = Number.MIN_VALUE;
    let minY = Number.MAX_VALUE;
    let maxY = Number.MIN_VALUE;

    // Helper function to traverse graph nodes and update coordinates
    const traverseGraph = (node, x, y) => {
      // Update min and max coordinates
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);

      // Adjust newX and newY based on your graph structure
      const newX = x + 200;
      const newY = y;
      const neighbors = data[node];
      for (const neighbor of neighbors) {
        traverseGraph(neighbor, newX, newY);
      }
    };

    // Start traversal from the starting point with initial coordinates (0, 0)
    traverseGraph(startingPoint, 0, 0);

    // Calculate and return width and height of the graph based on coordinates
    const width = maxX - minX;
    const height = maxY - minY;
    return {
      width,
      height
    };
  };
  const recurseGraph = (vis, node, x, y, ctx, pos, connections) => {
    if (!vis[node]) {
      const width = 100; // Rectangle width
      const height = 30; // Rectangle height

      // Scale and adjust node positions to fit within canvas
      let scaledX = x;
      let scaledY = y;
      if (scaledX < width / 2) scaledX = width / 2;
      if (scaledX > ctx.canvas.width - width / 2) scaledX = ctx.canvas.width - width / 2;
      if (scaledY < height / 2) scaledY = height / 2;
      if (scaledY > ctx.canvas.height - height / 2) scaledY = ctx.canvas.height - height / 2;

      // Draw node rectangle and text
      ctx.strokeRect(scaledX - width / 2, scaledY - height / 2, width, height);
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(node, scaledX, scaledY);

      // Update node position
      pos[node] = {
        x: scaledX,
        y: scaledY
      };
      vis[node] = true;
      const neighbors = data[node];
      const neighborCount = neighbors.length;
      let yOffset = -(neighborCount - 1) * 50;
      for (let i = 0; i < neighborCount; i++) {
        const neighbor = neighbors[i];
        const newX = scaledX + 200;
        const newY = scaledY + yOffset;
        if (!connections[`${node}-${neighbor}`] && !connections[`${neighbor}-${node}`]) {
          ctx.beginPath();
          ctx.moveTo(scaledX + width / 2, scaledY);
          ctx.lineTo(pos[neighbor] ? pos[neighbor].x - width / 2 : newX - width / 2, pos[neighbor] ? pos[neighbor].y : newY);
          ctx.stroke();
          connections[`${node}-${neighbor}`] = true;
        }
        recurseGraph(vis, neighbor, newX, newY, ctx, pos, connections);
        yOffset += 100;
      }
    }
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("canvas", {
    ref: canvasRef,
    width: mainWidth,
    height: mainHeight
  });
}
GraphVisualizer.displayName = "GraphVisualizer";
GraphVisualizer.defaultProps = {
  mainHeight: 400,
  mainWidth: 500,
  textColor: "black",
  data: {}
};
GraphVisualizer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "GraphVisualizer",
  "props": {
    "mainHeight": {
      "defaultValue": {
        "value": "400",
        "computed": false
      },
      "required": false
    },
    "mainWidth": {
      "defaultValue": {
        "value": "500",
        "computed": false
      },
      "required": false
    },
    "textColor": {
      "defaultValue": {
        "value": "\"black\"",
        "computed": false
      },
      "required": false
    },
    "data": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "required": false
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphVisualizer);

/***/ })

});
//# sourceMappingURL=Graph-stories.676f3ed7867e3109ba2a.hot-update.js.map