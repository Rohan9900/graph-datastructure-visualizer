"use strict";
self["webpackHotUpdategraph_data_structure_visualizer"]("Graph-stories",{

/***/ "./stories/Graph.js":
/*!**************************!*\
  !*** ./stories/Graph.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphVisualizer: () => (/* binding */ GraphVisualizer),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


function GraphVisualizer({
  isChange,
  startingPoint,
  textColor,
  data,
  mainWidth,
  mainHeight
}) {
  const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const contextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const scaleFactor = 1.5;
  const canvasWidth = 8000;
  const canvasHeight = 6000;
  let canvasX = 0;
  let canvasY = 0;
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const canvas = canvasRef.current;
    const context = canvas.getContext("2d");
    contextRef.current = context;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    drawCanvas();
  }, [isChange]);
  const drawCanvas = () => {
    const canvas = canvasRef.current;
    const context = contextRef.current;
    context.clearRect(0, 0, canvas.width, canvas.height);
    recurseGraph(startingPoint, 100, 300, context, {});
  };
  const recurseGraph = (node, x, y, ctx, pos) => {
    const width = 100;
    const height = 30;
    ctx.strokeRect(x - width / 2, y - height / 2, width, height);
    ctx.fillStyle = textColor;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(node, x, y);
    pos[node] = {
      x: x,
      y: y
    };
    const neighbors = data[node];
    const neighborCount = neighbors.length;
    let yOffset = -(neighborCount - 1) * 50;
    for (let i = 0; i < neighborCount; i++) {
      const neighbor = neighbors[i];
      const newX = x + 200;
      const newY = y + yOffset;
      ctx.beginPath();
      ctx.moveTo(x + width / 2, y);
      ctx.lineTo(pos[neighbor] ? pos[neighbor].x - width / 2 : newX - width / 2, pos[neighbor] ? pos[neighbor].y : newY);
      ctx.stroke();
      recurseGraph(neighbor, newX, newY, ctx, pos);
      yOffset += 200;
    }
  };
  const handleMouseMove = e => {
    if (e.buttons === 1) {
      canvasX -= e.movementX;
      canvasY -= e.movementY;
      drawCanvas();
    }
  };
  const handleWheel = e => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const zoomAmount = delta > 0 ? scaleFactor : 1 / scaleFactor;
    const canvas = canvasRef.current;
    const canvasRect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - canvasRect.left;
    const mouseY = e.clientY - canvasRect.top;
    const canvasXBeforeZoom = canvasX + mouseX;
    const canvasYBeforeZoom = canvasY + mouseY;
    canvasX = (canvasXBeforeZoom - mouseX) * zoomAmount + mouseX;
    canvasY = (canvasYBeforeZoom - mouseY) * zoomAmount + mouseY;
    canvasX = Math.max(canvasX, 0);
    canvasY = Math.max(canvasY, 0);
    canvas.width = canvasWidth * scaleFactor;
    canvas.height = canvasHeight * scaleFactor;
    drawCanvas();
  };
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("div", {
    ref: containerRef,
    style: {
      overflow: "hidden",
      width: "100%",
      height: "100%"
    },
    onMouseMove: handleMouseMove,
    onWheel: handleWheel,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)("canvas", {
      ref: canvasRef
    })
  });
}
GraphVisualizer.displayName = "GraphVisualizer";
GraphVisualizer.defaultProps = {
  mainHeight: 400,
  mainWidth: 500,
  textColor: "black",
  data: {}
};
GraphVisualizer.__docgenInfo = {
  "description": "",
  "methods": [],
  "displayName": "GraphVisualizer",
  "props": {
    "mainHeight": {
      "defaultValue": {
        "value": "400",
        "computed": false
      },
      "required": false
    },
    "mainWidth": {
      "defaultValue": {
        "value": "500",
        "computed": false
      },
      "required": false
    },
    "textColor": {
      "defaultValue": {
        "value": "\"black\"",
        "computed": false
      },
      "required": false
    },
    "data": {
      "defaultValue": {
        "value": "{}",
        "computed": false
      },
      "required": false
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GraphVisualizer);

/***/ })

});
//# sourceMappingURL=Graph-stories.6928d21c3e8ab8616680.hot-update.js.map